class CameraHelper(mcontext: Context) {
    private var cameraId: String = "-1"

    private val context: Context = mcontext
    private var onPreviewSizeListener: OnPreviewSizeListener? = null
    private var onPreviewListener: OnPreviewListener? = null


    /** Detects, characterizes, and connects to a CameraDevice (used for all camera operations) */
    private lateinit var cameraManager: CameraManager

    /** [CameraCharacteristics] corresponding to the provided Camera ID */
    private lateinit var characteristics: CameraCharacteristics

    /** Readers used as buffers for camera still shots */
    private lateinit var imageReader: ImageReader

    /** [HandlerThread] where all camera operations run */
    private var cameraThread: HandlerThread? = null

    /** [Handler] corresponding to [cameraThread] */
    private var cameraHandler: Handler? = null

    /** The [CameraDevice] that will be opened in this fragment */
    private var camera: CameraDevice? = null

    /** Internal reference to the ongoing [CameraCaptureSession] configured with our parameters */
    private var cameraCaptureSession: CameraCaptureSession? = null

    /** Live data listener for changes in the device orientation relative to the camera 横屏与竖屏检测 */
    private lateinit var relativeOrientation: OrientationLiveData

    /** 支持的awb模式,以及目前的模式 */
    private val awbModes = ArrayList<Int>()
    private var currentAWB = -1
    private var currentAWBIdx = -1

    /** Flag whether we should restart preview after an extension switch. */
    private var restartPreview = false

    /** SurfaceTexture  */
    private var surfaceTexture: SurfaceTexture? = null
    /** The [Size] of camera preview. */
    private lateinit var previewSize: Size
    /** [CaptureRequest.Builder] for the camera preview */
    private var previewRequestBuilder: CaptureRequest.Builder? = null
    /** [CaptureRequest] generated by [.mPreviewRequestBuilder] */
    private var previewRequest: CaptureRequest? = null

    fun getCameraId(): Int {
        return cameraId.toInt()
    }

    fun getSize(): Size {
        return previewSize
    }

    @SuppressLint("MissingPermission")
    fun openCamera(mSurfaceTexture: SurfaceTexture) {
        surfaceTexture = mSurfaceTexture
        startBackgroundThread()

        cameraManager = context.getSystemService(Context.CAMERA_SERVICE) as CameraManager
        //设置预览图像的大小，surfaceview的大小。
        setUpCameraOutputs()
        try {
            if (context.checkSelfPermission(Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) {
                // TODO: Consider calling
                //    Activity#requestPermissions
                // here to request the missing permissions, and then overriding
                //   public void onRequestPermissionsResult(int requestCode, String[] permissions,
                //                                          int[] grantResults)
                // to handle the case where the user grants the permission. See the documentation
                // for Activity#requestPermissions for more details.
                return
            }
            cameraManager.openCamera(cameraId, mStateCallback, cameraHandler)
        } catch (e: CameraAccessException) {
            e.printStackTrace()
        }
    }

    /**
     * [CameraDevice.StateCallback] is called when [CameraDevice] changes its state.
     */
    private val mStateCallback: CameraDevice.StateCallback = object : CameraDevice.StateCallback() {
        override fun onOpened(cameraDevice: CameraDevice) {
            // This method is called when the camera is opened.  We start camera preview here.
            camera = cameraDevice
            createCameraPreviewSession()
        }

        override fun onDisconnected(cameraDevice: CameraDevice) {
            cameraDevice.close()
            camera = null
        }

        override fun onError(cameraDevice: CameraDevice, error: Int) {
            cameraDevice.close()
            camera = null
        }
    }

    /**
     * Closes the current [CameraDevice].
     */
    fun closeCamera() {
        cameraCaptureSession?.close()
        cameraCaptureSession = null
        camera?.close()
        camera = null
        surfaceTexture?.release()
        surfaceTexture = null
        stopBackgroundThread()
    }

    /**
     * Starts a background thread and its [Handler].
     */
    private fun startBackgroundThread() {
        cameraThread = HandlerThread("cameraThread")
        cameraThread!!.start()
        cameraHandler = Handler(cameraThread!!.looper)
    }

    /**
     * Stops the background thread and its [Handler].
     */
    private fun stopBackgroundThread() {
        cameraThread?.quitSafely()
        try {
            cameraThread?.join()
            cameraThread = null
            cameraHandler = null
        } catch (e: InterruptedException) {
            e.printStackTrace()
        }
    }

    /** Sets up member variables related to camera. */
    private fun setUpCameraOutputs() {
        try {
            for (id :String in cameraManager.cameraIdList) {
                characteristics = cameraManager.getCameraCharacteristics(cameraId)

                // We don't use a front facing camera in this sample.
                val facing = characteristics.get(CameraCharacteristics.LENS_FACING)
                if (facing != null && facing != CameraCharacteristics.LENS_FACING_FRONT) {
                    continue
                }
                //获取所有支持的AWB模式
                awbModes.addAll(characteristics.get(CameraCharacteristics.CONTROL_AWB_AVAILABLE_MODES)!!.asList())

                if (currentAWB == -1) {
                    currentAWB = awbModes[0]
                    currentAWBIdx = 0
                    fragmentCameraBinding.switchButton!!.text = LableLib.getAWBLabel(currentAWB)
                }

                characteristics.get(
                    CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP
                ) ?: continue

                previewSize = characteristics.get(
                    CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP)!!
                    .getOutputSizes(PIXEL_FORMAT).maxByOrNull { it.height * it.width }!!

                onPreviewSizeListener?.onSize(previewSize.width, previewSize.height)

                imageReader = ImageReader.newInstance(
                    previewSize.width, previewSize.height, PIXEL_FORMAT, IMAGE_BUFFER_SIZE
                )
                imageReader.setOnImageAvailableListener(
                    onImageAvailableListener,
                    cameraHandler
                )
            }
        } catch (e: CameraAccessException) {
            e.printStackTrace()
        } catch (e: NullPointerException) {
        }
    }

    /**
     * Creates a new [CameraCaptureSession] for camera preview.
     */
    private fun createCameraPreviewSession() {
        try {
            // This is the output Surface we need to start preview.
            surfaceTexture!!.setDefaultBufferSize(previewSize.width, previewSize.height)
            val surface = Surface(surfaceTexture)

            // We set up a CaptureRequest.Builder with the output Surface.
            previewRequestBuilder = camera!!.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW)
            previewRequestBuilder!!.addTarget(surface)
            previewRequestBuilder!!.addTarget(imageReader.surface)

            // Here, we create a CameraCaptureSession for camera preview.
            camera!!.createCaptureSession(
                listOf(surface, imageReader.surface),
                object : CameraCaptureSession.StateCallback() {
                    override fun onConfigured(session: CameraCaptureSession) {
                        // The camera is already closed
                        if (null == camera) {
                            return
                        }

                        // When the session is ready, we start displaying the preview.
                        cameraCaptureSession = session
                        try {
                            // Auto focus should be continuous for camera preview.
                            previewRequestBuilder!!.set(
                                CaptureRequest.CONTROL_AF_MODE,
                                CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE
                            )
                            // Flash is automatically enabled when necessary.

                            // Finally, we start displaying the camera preview.
                            previewRequest = previewRequestBuilder!!.build()
                            cameraCaptureSession!!.setRepeatingRequest(
                                previewRequest!!,
                                captureCallback, cameraHandler
                            )
                        } catch (e: CameraAccessException) {
                            e.printStackTrace()
                        }
                    }

                    override fun onConfigureFailed(
                        session: CameraCaptureSession
                    ) {
                        Log.d(TAG, "onConfigureFailed: ")
                    }
                }, null
            )
        } catch (e: CameraAccessException) {
            e.printStackTrace()
        }
    }

    /**
     * A [CameraCaptureSession.CaptureCallback] that handles events related to JPEG capture.
     */
    private val captureCallback: CameraCaptureSession.CaptureCallback =
        object : CameraCaptureSession.CaptureCallback() {
            override fun onCaptureProgressed(
                session: CameraCaptureSession,
                request: CaptureRequest,
                partialResult: CaptureResult
            ) {
            }

            override fun onCaptureCompleted(
                session: CameraCaptureSession,
                request: CaptureRequest,
                result: TotalCaptureResult
            ) {
            }
        }

    fun setPreviewSizeListener(onPreviewSizeListener: OnPreviewSizeListener?) {
        this.onPreviewSizeListener = onPreviewSizeListener
    }

    private val onImageAvailableListener =
        ImageReader.OnImageAvailableListener { reader ->
            val image = reader.acquireNextImage() ?: return@OnImageAvailableListener
            val planes = image.planes
            val width = image.width
            val height = image.height
            val yBytes = ByteArray(width * height)
            val uBytes = ByteArray(width * height / 4)
            val vBytes = ByteArray(width * height / 4)
            val i420 = ByteArray(width * height * 3 / 2)
            for (i in planes.indices) {
                var dstIndex = 0
                val uIndex = 0
                val vIndex = 0
                val pixelStride = planes[i].pixelStride
                val rowStride = planes[i].rowStride
                val buffer = planes[i].buffer
                val bytes = ByteArray(buffer.capacity())
                buffer[bytes]
                var srcIndex = 0
                when (i) {
                    0 -> {
                        for (j in 0 until height) {
                            System.arraycopy(bytes, srcIndex, yBytes, dstIndex, width)
                            srcIndex += rowStride
                            dstIndex += width
                        }
                    }
                    1 -> {
                        for (j in 0 until height / 2) {
                            for (k in 0 until width / 2) {
                                uBytes[dstIndex++] = bytes[srcIndex]
                                srcIndex += pixelStride
                            }
                            if (pixelStride == 2) {
                                srcIndex += rowStride - width
                            } else if (pixelStride == 1) {
                                srcIndex += rowStride - width / 2
                            }
                        }
                    }
                    2 -> {
                        for (j in 0 until height / 2) {
                            for (k in 0 until width / 2) {
                                vBytes[dstIndex++] = bytes[srcIndex]
                                srcIndex += pixelStride
                            }
                            if (pixelStride == 2) {
                                srcIndex += rowStride - width
                            } else if (pixelStride == 1) {
                                srcIndex += rowStride - width / 2
                            }
                        }
                    }
                }
                System.arraycopy(yBytes, 0, i420, 0, yBytes.size)
                System.arraycopy(uBytes, 0, i420, yBytes.size, uBytes.size)
                System.arraycopy(vBytes, 0, i420, yBytes.size + uBytes.size, vBytes.size)
                onPreviewListener?.onPreviewFrame(i420, i420.size)
            }
            image.close()
        }

    fun setOnPreviewListener(onPreviewListener: OnPreviewListener?) {
        this.onPreviewListener = onPreviewListener
    }

    interface OnPreviewSizeListener {
        fun onSize(width: Int, height: Int)
    }

    interface OnPreviewListener {
        fun onPreviewFrame(data: ByteArray?, len: Int)
    }

    companion object {
        private val TAG = CameraFragment::class.java.simpleName

        private const val PIXEL_FORMAT = ImageFormat.YUV_420_888

        /** Maximum number of images that will be held in the reader's buffer */
        private const val IMAGE_BUFFER_SIZE: Int = 3

        /** Maximum time allowed to wait for the result of an image capture */
        private const val IMAGE_CAPTURE_TIMEOUT_MILLIS: Long = 5000

        /** Helper data class used to hold capture metadata with their associated image */
        data class CombinedCaptureResult(
            val image: Image,
            val metadata: CaptureResult,
            val orientation: Int,
            val format: Int
        ) : Closeable {
            override fun close() = image.close()
        }

        /**
         * Create a [File] named a using formatted timestamp with the current date and time.
         *
         * @return [File] created.
         */
        private fun createFile(context: Context, extension: String): File {
            val sdf = SimpleDateFormat("yyyy_MM_dd_HH_mm_ss_SSS", Locale.CHINA)
            return File(context.filesDir, "IMG_${sdf.format(Date())}.$extension")
        }
    }
}

