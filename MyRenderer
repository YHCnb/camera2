class MyRenderer (glRenderView: GlRenderView,mCameraHelper: CameraHelper): GLSurfaceView.Renderer,
    SurfaceTexture.OnFrameAvailableListener, CameraHelper.OnPreviewSizeListener,
    CameraHelper.OnPreviewListener {
    private val TAG = "MyRenderer"
    private var glRenderView: GlRenderView? = null
    private var cameraHelper: CameraHelper? = mCameraHelper
    private lateinit var mTextures: IntArray
    private var surfaceTexture: SurfaceTexture? = null
    private val mtx = FloatArray(16)
    private var screenFilter: ScreenFilter? = null
    private var cameraFilter: CameraFilter? = null
    private var mPreviewWdith = 0
    private var mPreviewHeight = 0
    private var avcRecorder: AvcRecorder? = null
    private var tracker: FaceTracker? = null
    private var bigeyeFilter: BigEyeFilter? = null
    private var stickerFilter: StickerFilter? = null
    private var beaytyFilter: BeautifyFilter? = null
    private var onRecordListener: OnRecordListener? = null
    private var onShootListener: OnShootListener? = null
    private var screenSurfaceWid = 0
    private var screenSurfaceHeight = 0
    private var screenX = 0
    private var screenY = 0
    private var stickEnable = false
    private var bigEyeEnable = false
    private var beautyEnable = false

    private var cameraMode = CameraMode.PHOTO
    private var isShooting = false
    private var shootPath = ""

    init{
        this.glRenderView = glRenderView
        val context = glRenderView.context


        val sdcardDir = Environment.getExternalStorageDirectory().path
        //拷贝 脸、眼部模型 TODO
        OpenGlUtils.copyAssets2SdCard(
            context, "lbpcascade_frontalface_improved.xml",
            "$sdcardDir/lbpcascade_frontalface.xml"
        )
        OpenGlUtils.copyAssets2SdCard(
            context, "seeta_fa_v1.1.bin",
            "$sdcardDir/seeta_fa_v1.1.bin"
        )
    }

    //当Surface创建后会调用此方法
    override fun onSurfaceCreated(gl: GL10?, config: javax.microedition.khronos.egl.EGLConfig?) {
        // 初始化OpenGL ES
//        cameraHelper = CameraHelper(glRenderView!!.context as Activity)

        mTextures = IntArray(1)
        //创建一个纹理
        GLES20.glGenTextures(mTextures.size, mTextures, 0)
        //将纹理和离屏buffer绑定
        surfaceTexture = SurfaceTexture(mTextures[0])
        //监听有新图像到来
        surfaceTexture!!.setOnFrameAvailableListener(this)

        //使用fbo 将samplerExternalOES 输入到sampler2D中
        cameraFilter = CameraFilter(glRenderView!!.context)
        //负责将图像绘制到屏幕上
        screenFilter = ScreenFilter(glRenderView!!.context)
    }

    //有新图像便会执行
    override fun onFrameAvailable(surfaceTexture: SurfaceTexture?) {
        glRenderView!!.requestRender()
    }

    //当Surface创建成功或尺寸改变时都调用此方法
    override fun onSurfaceChanged(gl: GL10?, width: Int, height: Int) {
        // 设置OpenGL ES视口
        cameraHelper!!.setPreviewSizeListener(this)
        cameraHelper!!.setOnPreviewListener(this)
        //打开相机 和追踪器
        cameraHelper!!.openCamera(surfaceTexture!!,width,height)
        val sdcardDir = Environment.getExternalStorageDirectory().path
        tracker = FaceTracker(
            "$sdcardDir/lbpcascade_frontalface.xml",
            "$sdcardDir/seeta_fa_v1.1.bin",
            cameraHelper
        )
        tracker!!.startTrack()

        val scaleX = mPreviewHeight.toFloat() / width.toFloat()
        val scaleY = mPreviewWdith.toFloat() / height.toFloat()
        val max = max(scaleX, scaleY)

        screenSurfaceWid = (mPreviewHeight / max).toInt()
        screenSurfaceHeight =(mPreviewWdith / max).toInt()
        screenX = width - (mPreviewHeight / max).toInt()
        screenY = height - (mPreviewWdith / max).toInt()

        //prepare 传如 绘制到屏幕上的宽 高 起始点的X坐标 起使点的Y坐标
        cameraFilter!!.prepare(screenSurfaceWid, screenSurfaceHeight, screenX, screenY)
        screenFilter!!.prepare(screenSurfaceWid, screenSurfaceHeight, screenX, screenY)

        val eglContext = EGL14.eglGetCurrentContext()
        avcRecorder = AvcRecorder(glRenderView!!.context, mPreviewHeight, mPreviewWdith, eglContext)
        avcRecorder!!.setOnRecordListener(onRecordListener)
    }

    //每绘制一帧都会调用此方法
    override fun onDrawFrame(gl: GL10?) {
        var textureId:Int
        // 配置屏幕
        //清理屏幕 :告诉opengl 需要把屏幕清理成什么颜色
        GLES20.glClearColor(0.0f,0.0f,0.0f,0.0f)
        //执行上一个：glClearColor配置的屏幕颜色
        GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT)

        //更新获取一张图
        surfaceTexture!!.updateTexImage()
        // 在此处绘制预览数据
        if (surfaceTexture != null) {
            // 更新SurfaceTexture，并在纹理上绘制
            surfaceTexture!!.updateTexImage()

            // 渲染预览纹理
            surfaceTexture!!.getTransformMatrix(mtx)
            //cameraFiler需要一个矩阵，是Surface和我们手机屏幕的一个坐标之间的关系
            cameraFilter!!.setMatrix(mtx)

            //获取相机的纹理 到surfaceTexture
            textureId = cameraFilter!!.onDrawFrame(mTextures[0])
            if (bigEyeEnable) {
                bigeyeFilter!!.setFace(tracker!!.mFace)
                textureId = bigeyeFilter!!.onDrawFrame(textureId)
            }
            if (beautyEnable) {
                textureId = beaytyFilter!!.onDrawFrame(textureId)
            }
            if (stickEnable) {
                stickerFilter!!.setFace(tracker!!.mFace)
                textureId = stickerFilter!!.onDrawFrame(textureId)
            }

            val id = screenFilter!!.onDrawFrame(textureId)
            when(cameraMode){
                CameraMode.PHOTO->{
                    //进行录制
                    avcRecorder!!.encodeFrame(id, surfaceTexture!!.timestamp)
                }
                CameraMode.VIDEO->{
                    if (isShooting){
                        //拍照并保存
                        isShooting=false
                        val bitmap = createBitmapFromTexture(textureId)
                        runBlocking {
                            saveResult(bitmap)
                            onShootListener!!.shootFinish(shootPath)
                        }
                    }
                }
            }
        }
    }

    /** 保存图片 */
    private suspend fun saveResult(bitmap: Bitmap) {
        try {
            val bos = BufferedOutputStream(FileOutputStream(shootPath))
            bitmap.compress(Bitmap.CompressFormat.JPEG,100,bos)
            bos.flush()
            bos.close()
        } catch (e: FileNotFoundException) {
            e.printStackTrace()
        } catch (e: IOException) {
            Log.e(TAG, "Unable to write JPEG image to file", e)
            Files.deleteIfExists(File(shootPath).toPath())
            e.printStackTrace()
        }
    }

    /** 从纹理中获得Bitmap */
    private fun createBitmapFromTexture(textureId:Int): Bitmap {
        val frameBuffer = IntArray(1)
        GLES20.glGenFramebuffers(1, frameBuffer, 0)
        GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, frameBuffer[0])

        // 绑定纹理对象到FrameBuffer
        GLES20.glFramebufferTexture2D(
            GLES20.GL_FRAMEBUFFER,
            GLES20.GL_COLOR_ATTACHMENT0,
            GLES20.GL_TEXTURE_2D,
            textureId,
            0
        )

        val snapWidth: Int = mPreviewHeight
        val snapHeight: Int = mPreviewWdith
        val size: Int = snapWidth * snapHeight
        val buf: ByteBuffer = ByteBuffer.allocateDirect(size * 4)
        buf.order(ByteOrder.nativeOrder())
        // 读取像素数据到buf
        GLES20.glReadPixels(
            0, 0, mPreviewWdith, mPreviewHeight,
            GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE,
            buf
        )
        val data = IntArray(size)
        buf.asIntBuffer().get(data)

        // 创建一个临时的Bitmap对象
        var bitmap = Bitmap.createBitmap(snapWidth, snapHeight, Bitmap.Config.ARGB_8888)
        bitmap.setPixels(data, size-snapWidth, -snapWidth, 0, 0, snapWidth, snapHeight)

        // 翻转Bitmap
        val matrix = Matrix()
        matrix.preScale(1F, -1F)
        bitmap = Bitmap.createBitmap(bitmap, 0, 0, mPreviewWdith, mPreviewHeight, matrix, false)

        // 解绑FrameBuffer和纹理
        GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, 0)
        // 释放FrameBuffer
        GLES20.glDeleteFramebuffers(1, frameBuffer, 0)

        return bitmap
    }

    fun onSurfaceDestroy() {
        if (cameraHelper != null) {
            cameraHelper!!.closeCamera()
            cameraHelper!!.setPreviewSizeListener(null)
        }
        cameraFilter?.release()
        screenFilter?.release()
        tracker!!.stopTrack()
        tracker = null
    }

    override fun onSize(width: Int, height: Int) {
        mPreviewWdith = width
        mPreviewHeight = height
        Log.e(TAG, "mPreviewWdith:$mPreviewWdith")
        Log.e(TAG, "mPreviewHeight:$mPreviewHeight")
    }

    fun shoot(path: String){
        shootPath = path
        isShooting = true
    }

    fun startRecord(speed: Float, path: String?) {
        avcRecorder!!.start(speed, path)
    }

    fun stopRecord() {
        avcRecorder!!.stop()
    }

    override fun onPreviewFrame(data: ByteArray?, len: Int) {
        if (tracker != null && (stickEnable || bigEyeEnable)) tracker!!.detector(data)
    }

    fun setOnRecordListener(onRecordListener: OnRecordListener?) {
        this.onRecordListener = onRecordListener
    }

    fun setOnShootListener(onShootListener: OnShootListener?) {
        this.onShootListener = onShootListener
    }

    fun setCameraMode(mode: CameraMode){
        this.cameraMode = mode
    }

    fun enableStick(isChecked: Boolean) {
        stickEnable = isChecked
        if (isChecked) {
            stickerFilter = StickerFilter(glRenderView!!.context)
            stickerFilter!!.prepare(screenSurfaceWid, screenSurfaceHeight, screenX, screenY)
        } else {
            stickerFilter!!.release()
            stickerFilter = null
        }
    }

    fun enableBigEye(isChecked: Boolean) {
        bigEyeEnable = isChecked
        if (isChecked) {
            bigeyeFilter = BigEyeFilter(glRenderView!!.context)
            bigeyeFilter!!.prepare(screenSurfaceWid, screenSurfaceHeight, screenX, screenY)
        } else {
            bigeyeFilter!!.release()
            bigeyeFilter = null
        }
    }

    fun enableBeauty(isChecked: Boolean) {
        beautyEnable = isChecked
        if (isChecked) {
            beaytyFilter = BeautifyFilter(glRenderView!!.context)
            beaytyFilter!!.prepare(screenSurfaceWid, screenSurfaceHeight, screenX, screenY)
        } else {
            beaytyFilter!!.release()
            beaytyFilter = null
        }
    }
}
